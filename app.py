import datetime

# The Flask class from the flask package represents your application. You must
# always import it.

from flask import Flask

# An application is an instance of the Flask class.
#
# The Flask constructor takes many optional arguments, but only one is required:
# the name of your application, which should be the name of the package or
# module. Flask uses this name to help with features like loading resources. For
# most cases, using the special variable __name__ is a safe choice.
#
# More details about the Flask class:
#
# https://flask.palletsprojects.com/en/stable/api/#flask.Flask

app = Flask(__name__)

# Routes tell Flask how to handle requests. Routes are functions registered to
# the Flask app using a Python decorator. Decorators are always prefixed with
# `@` and are written right before the function they decorate. Here, the
# `app.route` decorator is used for the `index` function. Learn more about
# decorators:
#
# https://docs.python.org/3/glossary.html#term-decorator
#
# A decorator specifies which HTTP requests a function will handle. The `route`
# decorator is the simplest: it uses only the request path and supports GET
# requests by default. For example, a GET request to `/` will be handled by the
# `index` function. This route does not handle POST requests unless configured.
# See the `route` decorator documentation for details:
#
# https://flask.palletsprojects.com/en/stable/api/#flask.Flask.route
#
# More about routing:
#
# https://flask.palletsprojects.com/en/stable/quickstart/#routing


@app.route("/")
def index():
    # A handler processes a request and returns a response to the client.
    #
    # The simplest response is a string, which Flask returns with the
    # `text/html` content type. When you return a string, the client (like a web
    # browser) will interpret it as a web page. That's why this example includes
    # a `<p>` tag.
    #
    # Handlers can return more than just HTML. For details on building
    # responses, see:
    #
    # https://flask.palletsprojects.com/en/stable/quickstart/#about-responses
    return "<p>Hello, world!</p>"


@app.route("/fail")
def fail():
    # Exceptions in your handler result in 500 responses. 5xx responses mean a
    # server error, usually temporary. When an exception occurs, a 500 status
    # code is correct: it means the error is on the server and should be fixed
    # by the programmer.
    raise Exception("surprise!")


@app.route("/time")
def time():
    # Because handlers are functions executing on the server, they can run
    # arbitrary code. The response returned to the user is usually dynamic, and
    # it is generated by the handler. Usually (but not in this example) the
    # response depends on the request data.
    return f"<p>The current date and time is <b>{datetime.datetime.now()}</b></p>"


# If a user requests a route that isn't defined, like `/banana`, Flask returns a
# 404 response. 4xx status codes mean the error is caused by the client (e.g.,
# an unknown path). 404 means the requested resource was "not found" on the
# server.
#
# Repeating the request won't change the result unless the server adds that
# route. Therefore, a 404 status code is the most sensible response for unknown
# paths.
