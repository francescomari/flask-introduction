# The Flask class from the flask package represents your application. While
# Flask contains several other components, using the Flask class is mandatory in
# every application. You will always have to import it.

from flask import Flask

# An application is an instance of the Flask class.
#
# The constructor of the Flask class can receive a lot of arguments, but almost
# all of them are optional. The only required argument to the constructor is the
# name of the application, which must be the name of the package or module of
# your application. This might sound weird, but Flask will use this name to
# simplify more advanced features like automatically loading other resources
# that your application might need. Because the details of this mandatory
# parameter are not really important, and because your applications will
# probably be contained to a single module (file), using the special variable
# __name__ is always a safe option.
#
# You can find more details about the Flask class here:
#
# https://flask.palletsprojects.com/en/stable/api/#flask.Flask

app = Flask(__name__)

# Routes tell Flask how you want to handle requests. Routes are functions that
# are registered to the Flask application using a Python decorator. Python
# decorators are always prefixed with a `@` character and are written right
# before the function they are decorating. In this case, the `app.route`
# decorator is decorating the `index` function. For further information about
# decorators, read this definition and follow the linked pages:
#
# https://docs.python.org/3/glossary.html#term-decorator
#
# A decorator answers the question: what kind of HTTP request will this function
# take care of? The `route` decorator is the simplest decorator there is,
# because it will only use the request path to decide which function will be
# called. In this case, a request with a path of `/` will be handled by the
# `index` function. Because the `route` decorator only looks at the request
# path, both GET and POST requests to the path `/` will be handled by the `index`
# function. For more details about routing, see:
#
# https://flask.palletsprojects.com/en/stable/quickstart/#routing


@app.route("/")
def index():
    # A handler is responsible for handling a request and returning some
    # response to the client. Depending on what your application does, your
    # handler can perform different actions and return different responses to
    # the clients.
    #
    # The simplest response a handler can return is a string, which is always
    # returned to the client with the `text/html` content type. That is, when
    # you return a string, you are returning content that the client (possibly,
    # a web browser) will interpret as a web page. That's why this example
    # includes a `<p>` tag in the returned string.
    #
    # Handlers are not limited to returning HTML pages. For a full description
    # of how handlers build responses, see:
    #
    # https://flask.palletsprojects.com/en/stable/quickstart/#about-responses
    return "<p>Hello, world!</p>"


@app.route("/fail")
def fail():
    # Exceptions in your handler result in 500 responses. As you might know, 5xx
    # responses mean that the error is due to some problem on the server, and
    # that it might be temporary. When an exception occurs, a 500 status code is
    # the correct one: it occurs on the server because a programmer made a
    # mistake, and it is temporary because it will go away as soon as the
    # programmer fixes his or her code.
    raise Exception("surprise!")


# Now, what happens if a user sends a request to a route that we didn't define,
# like `/banana`? You can try for yourself! If Flask doesn't know how to handle
# a request because no handler is capable of doing that, it will simply return a
# 404 response to the client. This is the most sensible response to return. A
# 4xx status code means that the error was generated by the client (because they
# are sending a request that the server doesn't understand), and it's not meant
# to be automatically solved if the request is repeated (because if the server
# doesn't understand `/banana`, the response will not change no matter how many
# requests the client sends). In particular, 404 is a very good status code to
# send, because it means that the requested resource (path) was "not found" on
# the server.
